# Payment Integration Strategy & Fundamentals 

## 1. The Mental Model (How it works)

Forget the code for a second. Think of payment integration as a **3-Way Handshake**.

1.  **The Trigger (Frontend):** The user says "I want to pay."
2.  **The Permission (Backend):** The server says "Okay, here is a secure Order ID / Intent."
3.  **The Execution (Gateway):** The browser hands off control to the Gateway (Stripe/Razorpay) to collect money.
4.  **The Verification (Webhook):** The Gateway calls your Backend directly to say "Money received."

> **Core Rule:** The Frontend is for **UX**. The Backend is for **Truth**.

---

## 2. The Players (Who is who?)

### A. The Gateways (Processors)

- **Stripe / Razorpay:** They process the card. You are the merchant. You handle taxes.
- **PayPal:** The "Wallet" approach. Users pay via their account.
- **Paddle / CleverBridge:** These are **Merchant of Record (MoR)**. They legally sell the product _for_ you. They handle taxes (VAT/GST) and invoices.

### B. The Comparison Strategy (When to use what?)

| Provider         | Type    | Best For                     | Pitfall                                            |
| :--------------- | :------ | :--------------------------- | :------------------------------------------------- |
| **Razorpay**     | Gateway | üáÆüá≥ India Focus, Startups     | International failure rates can be higher.         |
| **Stripe**       | Gateway | üåç Global SaaS, Marketplaces | You must handle Taxes/Invoicing yourself.          |
| **PayPal**       | Wallet  | üõí E-commerce, Trust         | Developer Experience (DX) is historically painful. |
| **Paddle**       | MoR     | üì¶ B2B SaaS, Digital Goods   | Higher fees (5%+), but zero tax headache.          |
| **CleverBridge** | MoR     | üè¢ Enterprise Software       | Complex setup, strict compliance.                  |
| **Juspay**       | Gateway | üáÆüá≥ India Focus, Mobile-First | Less global reach, relies on India stack.          |

---

## 3. The Implementation (Vanilla JS + Mock Backend)

In a real app, you fetch configuration from your backend. For this guide, we use **Dummy Data** to simulate that response.

### Step 1: The Mock Backend Response

_Imagine your API endpoint `/api/create-order` returned this JSON:_

```javascript
// mockBackendResponse.js
const backendConfig = {
  // Common Data
  amount: 49900, // 499.00 (Always use lowest currency unit)
  currency: 'USD',
  userEmail: 'john@example.com',

  // Razorpay Specifics
  rzp_key: 'rzp_test_123456',
  rzp_order_id: 'order_9A33XWu170gUtm', // Generated by Backend

  // Stripe Specifics
  stripe_pk: 'pk_test_123456',
  stripe_client_secret: 'pi_123_secret_456', // Payment Intent Secret

  // Paddle Specifics
  paddle_vendor_id: 12345,
  paddle_product_id: 56789,
};
```

---

### Step 2: Razorpay Integration (The "Order" Model)

_Mental Model: Create Order on Server ‚Üí Open Modal on Client ‚Üí Verify Signature on Server._

```javascript
function payWithRazorpay() {
  const options = {
    key: backendConfig.rzp_key,
    amount: backendConfig.amount,
    currency: 'INR', // Razorpay default
    name: 'My Store',
    order_id: backendConfig.rzp_order_id, // ‚ö†Ô∏è CRITICAL: Must come from backend

    // The Handler: What happens after success?
    handler: function (response) {
      console.log('Payment ID:', response.razorpay_payment_id);
      console.log('Signature:', response.razorpay_signature);

      // üöÄ Step 3: Send this data to YOUR backend to verify signature
      // verifyPayment(response);
    },
    prefill: {
      email: backendConfig.userEmail,
    },
  };

  // Vanilla JS initialization
  const rzp1 = new window.Razorpay(options);
  rzp1.on('payment.failed', function (response) {
    alert('Payment Failed: ' + response.error.description);
  });
  rzp1.open();
}
```

---

### Step 3: Stripe Integration (The "Intent" Model)

_Mental Model: Create Intent ‚Üí Confirm Intent. Stripe handles 3D Secure automatically._

```javascript
// distinct from Razorpay: Stripe needs an instantiated Element
async function payWithStripe() {
  const stripe = window.Stripe(backendConfig.stripe_pk);

  // Confirm the payment using the Client Secret from backend
  const { error, paymentIntent } = await stripe.confirmCardPayment(backendConfig.stripe_client_secret, {
    payment_method: {
      card: cardElement, // Assumes you mounted a Stripe Element
      billing_details: { name: 'John Doe' },
    },
  });

  if (error) {
    console.error('Failed:', error.message);
  } else if (paymentIntent.status === 'succeeded') {
    console.log('Money is safe:', paymentIntent.id);
    // üöÄ Inform backend (Optional, strictly rely on Webhook)
  }
}
```

---

### Step 4: Paddle (The "Overlay" Model)

_Mental Model: You don't manage orders. You just trigger a checkout for a Product ID._

```javascript
function payWithPaddle() {
  // Initialize
  window.Paddle.Setup({ vendor: backendConfig.paddle_vendor_id });

  // Open Checkout
  window.Paddle.Checkout.open({
    product: backendConfig.paddle_product_id,
    email: backendConfig.userEmail,
    successCallback: function (data) {
      console.log('Paddle Success:', data);
      // Paddle automatically handles emails/invoices.
      // You just wait for the webhook.
    },
    closeCallback: function () {
      console.log('User closed the popup');
    },
  });
}
```

---

### Step 5: Juspay Integration (The "Direct / UPI" Model)

_Mental Model: Highly integrated for India-specific payment flows (UPI, Netbanking, Wallets)._

```javascript
async function payWithJuspay() {
  // Assume backend provides an order ID and Juspay-specific payload
  // const juspayConfig = await fetch('/api/create-juspay-order').then(res => res.json());

  const juspayConfig = {
    order_id: 'JP_ORDER_12345', // From your backend
    customer_id: 'CUST_ABC',
    amount: backendConfig.amount / 100, // Juspay usually expects INR
    currency: 'INR',
    merchant_id: 'YOUR_MERCHANT_ID', // Provided by Juspay
    return_url: 'https://yourwebsite.com/payment-success',
    // Further configurations for UPI, Netbanking, etc.
    payment_methods: ['UPI', 'NB', 'CARD'],
    upi_collect_request: {
      vpa: 'user@bank', // Optional prefill
    },
  };

  // Juspay's SDK typically involves a redirect or opening a webview
  // This is a simplified representation.
  const options = {
    ...juspayConfig,
    // Callback for success/failure
    callback: (result) => {
      if (result.status === 'CHARGED') {
        console.log('Juspay Payment Succeeded:', result);
        // üöÄ CRITICAL: Verify this on your backend using Juspay's server-to-server API
      } else {
        console.error('Juspay Payment Failed:', result);
      }
    },
  };

  // Example: Redirect to Juspay's hosted page (simplified)
  // window.location.href = `https://api.juspay.in/payments?orderId=${juspayConfig.order_id}&...`;

  // Or if using a JS SDK, it might render a modal/webview
  // window.Juspay.startPayment(options);
  console.log('Juspay payment flow initiated with options:', options);
}
```

---

## 4. Architectural Patterns (Interview Gold)

### Pattern A: The "Strategy" Pattern (Frontend)

How to handle multiple gateways dynamically?

```javascript
function handleCheckout(gatewayName) {
  switch (gatewayName) {
    case 'razorpay':
      return payWithRazorpay();
    case 'stripe':
      return payWithStripe();
    case 'paddle':
      return payWithPaddle();
    case 'juspay':
      return payWithJuspay();
    default:
      throw new Error('Unknown Gateway');
  }
}
```

### Pattern B: The Webhook (Backend)

**Interviewer:** "What if the user's internet dies right after they pay, but before your frontend gets the success message?"
**You:** "That is why we rely on **Webhooks**."

1.  Gateway takes money.
2.  Frontend crashes (Internet/Battery dies).
3.  Gateway sends a HTTP POST to `https://api.myapp.com/webhook`.
4.  Server updates DB: `Order #123 -> PAID`.
5.  User comes back later -> Sees "Paid".

### Pattern C: Idempotency Keys (Preventing Double Charges)

**Problem:** User clicks "Pay" twice quickly, or retries a failed request.
**Solution:** Generate a unique `Idempotency-Key` (e.g., your order ID) on your backend for each transaction and send it to the payment gateway. The gateway will ensure that only the first request with that key is processed, preventing double charges.

### Pattern D: Simplified Backend Flow (Node.js/Express Example)

This dummy backend flow illustrates how your server would interact with payment gateways. This logic should *never* be exposed on the frontend.

```javascript
// server.js (Simplified Node.js/Express Backend)
const express = require('express');
const bodyParser = require('body-parser');
const app = express();
const PORT = 3000;

// --- IMPORTANT: Replace with your actual secret keys ---
// In a real app, these come from environment variables (e.g., process.env.RAZORPAY_KEY_SECRET)
const RAZORPAY_KEY_SECRET = 'your_razorpay_key_secret';
const STRIPE_SECRET_KEY = 'your_stripe_secret_key';

// Mock Razorpay instance (in reality, you'd use a library like 'razorpay')
const MockRazorpay = {
  orders: {
    create: async (options) => ({ id: `order_mock_${Math.random().toString(36).substring(7)}`, ...options }),
    fetch: async (orderId) => ({ id: orderId, status: 'paid', amount: 50000 }) // Mock paid order
  },
  payments: {
    fetch: async (paymentId) => ({ id: paymentId, status: 'captured', amount: 50000, signature: 'mock_signature' })
  },
  utils: {
    verifyPaymentSignature: (body, signature, secret) => {
      // In a real app, this is a cryptographic verification.
      return signature === 'mock_signature'; // Simplified mock
    }
  }
};

// Mock Stripe instance (in reality, you'd use a library like 'stripe')
const MockStripe = {
  paymentIntents: {
    create: async (options) => ({ client_secret: `pi_mock_secret_${Math.random().toString(36).substring(7)}`, ...options }),
    retrieve: async (paymentIntentId) => ({ id: paymentIntentId, status: 'succeeded', amount: 50000 })
  }
};


// Middleware to parse JSON request bodies
app.use(bodyParser.json());

// --- Endpoint 1: Create Payment Intent / Order (Initiates Transaction) ---
// Frontend calls this to get secure transaction details.
app.post('/api/create-payment-intent', async (req, res) => {
  const { amount, currency, gateway, productId, userEmail } = req.body; // Example data from frontend

  if (!amount || !currency || !gateway) {
    return res.status(400).json({ error: 'Missing required payment details.' });
  }

  try {
    let responseData = {};
    if (gateway === 'razorpay') {
      const order = await MockRazorpay.orders.create({
        amount: amount * 100, // Convert to paise
        currency: currency,
        receipt: `receipt_${productId}`,
        payment_capture: 1 // Auto capture
      });
      responseData = {
        rzp_key: 'rzp_test_123456', // Your public key
        rzp_order_id: order.id,
        amount: order.amount,
        currency: order.currency,
        userEmail: userEmail
      };
    } else if (gateway === 'stripe') {
      const paymentIntent = await MockStripe.paymentIntents.create({
        amount: amount * 100, // Convert to cents
        currency: currency,
        metadata: { productId, userEmail }
      });
      responseData = {
        stripe_pk: 'pk_test_123456', // Your public key
        stripe_client_secret: paymentIntent.client_secret,
        amount: amount * 100,
        currency: currency,
        userEmail: userEmail
      };
    } else {
      return res.status(400).json({ error: 'Unsupported gateway.' });
    }

    // --- CRITICAL: Save order details to your database with status "PENDING" ---
    // Example: await saveOrderToDb({ ...req.body, status: 'PENDING', gatewayOrderId: order.id });

    res.json({ success: true, ...responseData });

  } catch (error) {
    console.error('Error creating payment intent:', error);
    res.status(500).json({ error: 'Failed to create payment intent.' });
  }
});

// --- Endpoint 2: Webhook Handler (Verifies Transaction) ---
// This endpoint receives POST requests from payment gateways after a transaction.
app.post('/api/webhook/:gateway', (req, res) => {
  const { gateway } = req.params;

  // --- IMPORTANT: Verify the webhook signature to ensure it's from the actual gateway ---
  // Each gateway has its own verification method.
  let isSignatureValid = false;
  if (gateway === 'razorpay') {
    const SH_SIGNATURE = req.headers['x-razorpay-signature'];
    // isSignatureValid = MockRazorpay.utils.verifyPaymentSignature(req.body, SH_SIGNATURE, RAZORPAY_KEY_SECRET);
    isSignatureValid = true; // Simplified mock
  } else if (gateway === 'stripe') {
    const SH_SIGNATURE = req.headers['stripe-signature'];
    // isSignatureValid = MockStripe.webhooks.constructEvent(req.body, SH_SIGNATURE, STRIPE_WEBHOOK_SECRET);
    isSignatureValid = true; // Simplified mock
  } else {
    return res.status(400).send('Unsupported gateway for webhook.');
  }

  if (!isSignatureValid) {
    console.warn('Webhook signature verification failed for', gateway);
    return res.status(400).send('Webhook signature verification failed.');
  }

  // --- Process the webhook event ---
  const event = req.body;
  // Example: Handle different event types (e.g., payment_succeeded, order_paid)
  if (gateway === 'razorpay' && event.event === 'payment.captured') {
    const paymentId = event.payload.payment.entity.id;
    const orderId = event.payload.order.entity.id;
    console.log(`Razorpay Payment Captured: ${paymentId} for Order: ${orderId}`);
    // --- CRITICAL: Update your database with order status "PAID" ---
    // Example: await updateOrderStatusInDb(orderId, 'PAID', paymentId);
    // console.log('DB updated to PAID');
  } else if (gateway === 'stripe' && event.type === 'payment_intent.succeeded') {
    const paymentIntentId = event.data.object.id;
    console.log(`Stripe Payment Intent Succeeded: ${paymentIntentId}`);
    // --- CRITICAL: Update your database with order status "PAID" ---
    // Example: await updateOrderStatusInDb(paymentIntentId, 'PAID');
    // console.log('DB updated to PAID');
  } else {
    console.log(`Unhandled webhook event for ${gateway}:`, event.type || event.event);
  }

  res.status(200).send('Webhook Received.');
});

// Start the server
app.listen(PORT, () => {
  console.log(`Backend Server listening at http://localhost:${PORT}`);
});
```

*(Note: This is a highly simplified mock. In a real application, you would use actual SDKs, robust error handling, database interactions, and more secure secret management.)*

### Pattern E: Payment Gateway SDKs / Hosted Fields (PCI Compliance)

**Problem:** Handling credit card numbers directly on your servers requires stringent PCI DSS compliance, which is complex and expensive.
**Solution:** Use the payment gateway's client-side SDKs or hosted fields (iframes). This means sensitive card data never touches your servers; it's sent directly from the user's browser to the payment gateway. Your server only receives a token representing the card.

---

## 6. Pitfalls & "Gotchas" ‚ö†Ô∏è

1.  **Trusting the Frontend:**
    - ‚ùå _Bad:_ Frontend sends `{ status: "success", amount: 100 }` to backend.
    - ‚úÖ _Good:_ Frontend sends `{ payment_id: "pay_123" }`. Backend asks Gateway: "Did pay_123 actually pay us 100?" **Always verify payment status and amount on the backend.**

2.  **Currency Decimals (Lowest Unit):**
    - Stripe/Razorpay usually expect amounts in **cents/paise** (Integers).
    - $10.00 = `1000` (cents).
    - ‚ùå Sending `10` might charge 10 cents. **Always convert to the lowest currency unit (e.g., multiply by 100 for USD/INR) before sending to the gateway.**

3.  **Network Latency & Timeouts:**
    - Payment gateway APIs can be slow. Implement proper timeouts and retry mechanisms on your backend.
    - Inform the user of payment processing status.

4.  **Security of Webhooks:**
    - Webhooks must be secured to prevent fraud. Verify the signature or IP address of incoming webhook requests to ensure they are genuinely from the payment gateway.

---

## 7. Interview Q&A Cheatsheet

**Q: Why do we need a backend for payment integration? Can't I do it all in frontend JavaScript?**
**A:** No, a backend is critical. It keeps your **secret API keys** secure and provides a trusted environment to verify payment status via webhooks. Exposing secret keys on the frontend would allow malicious users to refund transactions or commit fraud.

**Q: What is the difference between Authorization and Capture in payments?**
**A:**

- **Authorization:** Reserves funds on the customer's card. The money is "held" but not yet transferred (common in hotel bookings or pre-orders).
- **Capture:** The actual transfer of funds from the customer's account to your merchant account.
- Most e-commerce transactions perform immediate "Auth & Capture."

**Q: Why would a company choose Paddle (or CleverBridge) over Stripe or Razorpay?**
**A:** Companies choose a Merchant of Record (MoR) like Paddle to offload complex global tax (VAT, GST), compliance, and invoicing headaches. MoRs legally sell the product for you. While their fees are higher, they eliminate the need for an internal finance team to manage international sales tax, which is invaluable for digital product companies selling globally.

**Q: What is PCI DSS Compliance, and how does using Stripe/Razorpay SDKs help with it?**
**A:** PCI DSS (Payment Card Industry Data Security Standard) is a set of security standards for organizations that handle branded credit cards. It's very complex. By using a payment gateway's client-side SDKs or hosted fields (e.g., Stripe Elements, Razorpay Checkout), sensitive card data never touches your servers. It's sent directly from the user's browser to the gateway, significantly reducing your PCI DSS compliance burden.

**Q: How do you handle a scenario where a user closes the browser tab immediately after making a payment, but before your frontend receives a success message?**
**A:** We rely on **webhooks**. The payment gateway sends a server-to-server notification (a webhook) to our backend when the payment status changes (e.g., successful). Our backend receives this notification, updates the order status in the database, and then notifies the user via email or displays the correct status when they revisit the site. The frontend success message is secondary to the backend's verification.

---

## 8. Summary for Developers

1.  **Frontend:** UI ‚Üí Collects User Intent ‚Üí Initiates Payment (opens Gateway Modal/Redirects).
2.  **Backend:** Generates Secure Transaction (Order ID/Client Secret) ‚Üí Verifies Payment Status (Server-to-Server) ‚Üí Listens to Webhooks (CRITICAL for reliability).
3.  **Database:** Only update order status to "PAID" after backend verification (Webhook or direct Gateway API call).
4.  **Security:** Never touch raw credit card data. Always use Gateway SDKs/Hosted Fields for PCI Compliance.
5.  **Idempotency:** Implement idempotency keys for all payment requests to prevent duplicate transactions.
