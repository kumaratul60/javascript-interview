# JavaScript Design Patterns — A Practical, Real‑World Guide

> **Scope:** Pure JavaScript (browser + Node). Each pattern includes a clear definition, when to use, a realistic problem, how to implement, a compact code snippet, pros/cons, and quick tests.

---

## How to pick a pattern (quick map)

* **Organizing code / encapsulation** → Module, Revealing Module, Facade
* **One shared instance / shared cache** → Singleton
* **Create objects without `new` soup** → Factory, Builder
* **Swap algorithms at runtime** → Strategy, State
* **Broadcast events / decouple producers & consumers** → Observer (Pub/Sub), Mediator
* **Wrap/extend behavior without subclassing** → Decorator, Proxy
* **Make APIs compatible** → Adapter
* **Simplify a complex API** → Facade
* **Operate requests as objects** → Command, Chain of Responsibility
* **Control iteration** → Iterator
* **Optimize memory for many similar objects** → Flyweight
* **Share structure between objects** → Prototype

> Tip: Start with simplest pattern that solves the problem; avoid stacking patterns prematurely.

---

## 1) Module Pattern

**Definition:** Encapsulate private data/functions and expose a public API.

**When to use:**

* You need private variables in plain JS without classes.
* To group related functionality (e.g., cart, analytics, feature flags).

**Real‑world problem:** Prevent global leaks in an embeddable widget and expose a tiny API.

**Code (IIFE style):**

```js
const Cart = (function () {
  const items = new Map(); // private

  function add(productId, qty = 1) {
    items.set(productId, (items.get(productId) || 0) + qty);
  }
  function remove(productId) {
    items.delete(productId);
  }
  function totalQty() {
    let sum = 0; for (const q of items.values()) sum += q; return sum;
  }

  return { add, remove, totalQty }; // public API
})();

Cart.add("SKU123", 2);
console.log(Cart.totalQty()); // 2
```

**Pros:** Simple privacy, clear API. **Cons:** Harder to unit test private parts; not easily extensible.

**Quick tests:** No globals leaked, API surface minimal, private state truly inaccessible.

---

## 2) Revealing Module Pattern

**Definition:** Define all functions/vars privately, then return an object mapping private names to public ones.

**When to use:**

* Keep a consistent style: all functions at top, exports at bottom.
* Make it obvious what’s public.

**Real‑world problem:** Token storage wrapper that exposes only safe methods.

**Code:**

```js
const TokenStore = (function () {
  const KEY = "app:token"; // private
  function set(token) { localStorage.setItem(KEY, token); }
  function get() { return localStorage.getItem(KEY); }
  function clear() { localStorage.removeItem(KEY); }

  // reveal what’s public
  return { setToken: set, getToken: get, clear };
})();

TokenStore.setToken("abc123");
```

**Pros:** Export list is the single source of truth. **Cons:** Same as Module; circular references harder.

---

## 3) Singleton Pattern

**Definition:** Ensure a class/object has only one instance and provide a global access point.

**When to use:**

* App‑wide config, logger, cache, DB connection, feature flag provider.
* You truly need single ownership of a resource.

**Real‑world problem:** Ensure only one analytics queue exists on a page with multiple bundles.

**Code (idempotent global attach):**

```js
class Analytics {
  constructor() { this.queue = []; }
  track(event, payload) { this.queue.push({ event, payload, ts: Date.now() }); }
}

// Safe singleton across duplicate bundles
const AnalyticsSingleton = (function () {
  const GLOBAL_KEY = "__app_analytics__";
  if (!globalThis[GLOBAL_KEY]) {
    globalThis[GLOBAL_KEY] = new Analytics();
  }
  return globalThis[GLOBAL_KEY];
})();

AnalyticsSingleton.track("page_view", { path: location.pathname });
```

**Pros:** Single source of truth. **Cons:** Hidden dependencies; complicates tests—use DI to inject where possible.

---

## 4) Factory Pattern

**Definition:** Provide a function to create objects without exposing complex constructors.

**When to use:**

* You create many variants of a type based on input.
* Instantiation logic changes often (e.g., from config/env).

**Real‑world problem:** Create API clients switching base URL/auth by environment.

**Code:**

```js
function createHttpClient({ env = "prod", token } = {}) {
  const base = env === "dev" ? "https://api.dev.local" : "https://api.example.com";
  return {
    get(path) { return fetch(base + path, { headers: { Authorization: `Bearer ${token}` } }); },
    post(path, body) { return fetch(base + path, { method: "POST", headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` }, body: JSON.stringify(body) }); }
  };
}

const client = createHttpClient({ env: "dev", token: "t123" });
```

**Pros:** Centralize creation. **Cons:** Easy to hide complexity—document it.

---

## 5) Builder Pattern

**Definition:** Construct complex objects step by step via a fluent API.

**When to use:**

* Many optional fields / defaulting / validation.
* You need readable, staged construction.

**Real‑world problem:** Building a report export request.

**Code:**

```js
function ReportBuilder() {
  const req = { format: "csv", filters: {}, columns: [] };
  return {
    format(fmt) { req.format = fmt; return this; },
    filter(key, val) { req.filters[key] = val; return this; },
    column(name) { req.columns.push(name); return this; },
    build() { if (req.columns.length === 0) throw new Error("At least one column"); return { ...req }; }
  };
}

const request = ReportBuilder().format("xlsx").filter("from", "2025-01-01").column("userId").column("revenue").build();
```

**Pros:** Fluent, validated. **Cons:** Extra abstraction; keep it lean.

---

## 6) Strategy Pattern

**Definition:** Define a family of algorithms, encapsulate each, and make them interchangeable.

**When to use:**

* You switch algorithms based on context (e.g., sorting, pricing rules, discount logic).

**Real‑world problem:** Different discount strategies by user tier.

**Code:**

```js
const strategies = {
  none: (amount) => amount,
  silver: (amount) => amount * 0.95,
  gold: (amount) => amount * 0.9,
};

function applyDiscount(amount, tier = "none") {
  const fn = strategies[tier] || strategies.none;
  return fn(amount);
}

applyDiscount(100, "gold"); // 90
```

**Pros:** Open/closed friendly. **Cons:** Too many small functions—document clearly.

---

## 7) State Pattern

**Definition:** Let an object change its behavior when its internal state changes.

**When to use:**

* UI components with modes (idle/loading/error), order lifecycle (draft/paid/shipped), auth guards.

**Real‑world problem:** Button that behaves differently by state.

**Code:**

```js
function createAsyncButton() {
  let state = "idle"; // idle | loading | success | error
  const actions = {
    idle: () => { state = "loading"; },
    loading: () => {},
    success: () => { state = "idle"; },
    error: () => { state = "idle"; }
  };
  return {
    click() { actions[state](); },
    setState(s) { state = s; },
    getState() { return state; }
  };
}
```

**Pros:** Removes giant `if/else` blocks. **Cons:** More objects; keep states finite and explicit.

---

## 8) Observer (Publish/Subscribe) Pattern

**Definition:** Objects (subscribers) register interest in events from a subject (publisher).

**When to use:**

* Decouple data producers from UI, analytics, or logging.

**Real‑world problem:** Central event bus for cross‑feature communication.

**Code:**

```js
function createPubSub() {
  const topics = new Map(); // topic -> Set(listeners)
  return {
    subscribe(topic, listener) {
      if (!topics.has(topic)) topics.set(topic, new Set());
      topics.get(topic).add(listener);
      return () => topics.get(topic)?.delete(listener); // unsubscribe
    },
    publish(topic, data) {
      topics.get(topic)?.forEach((l) => l(data));
    }
  };
}

const bus = createPubSub();
const off = bus.subscribe("user:login", (u) => console.log("welcome", u.name));
bus.publish("user:login", { name: "Atul" });
off();
```

**Pros:** Loosely coupled. **Cons:** Hard to trace flow—name topics clearly.

---

## 9) Mediator Pattern

**Definition:** Encapsulate how a set of objects interact; promotes loose coupling by preventing direct references.

**When to use:**

* Complex UIs where components must coordinate (wizard steps, chat presence + typing + messages).

**Real‑world problem:** Form wizard mediator controlling step transitions.

**Code:**

```js
function createWizardMediator(steps) {
  let current = 0;
  return {
    next() { if (steps[current].validate()) current++; steps[current]?.render(); },
    prev() { if (current > 0) current--; steps[current].render(); },
    currentIndex() { return current; }
  };
}
```

**Pros:** Centralizes coordination. **Cons:** Mediator can bloat—keep logic cohesive.

---

## 10) Command Pattern

**Definition:** Encapsulate a request as an object to parameterize, queue, log, and support undo/redo.

**When to use:**

* Editors (text/canvas), macro systems, retry queues.

**Real‑world problem:** Text editor operations with undo/redo.

**Code:**

```js
function createEditor() {
  let text = "";
  const history = []; const undone = [];

  const exec = (command) => { history.push(command); command.do(); undone.length = 0; };
  const undo = () => { const c = history.pop(); if (c) { c.undo(); undone.push(c); } };
  const redo = () => { const c = undone.pop(); if (c) { c.do(); history.push(c); } };

  return {
    insert(pos, str) { exec({ do: () => text = text.slice(0,pos)+str+text.slice(pos), undo: () => text = text.slice(0,pos)+text.slice(pos+str.length) }); },
    remove(pos, len) { const old = text.slice(pos, pos+len); exec({ do: () => text = text.slice(0,pos)+text.slice(pos+len), undo: () => text = text.slice(0,pos)+old+text.slice(pos) }); },
    getText: () => text, undo, redo
  };
}
```

**Pros:** Powerful undo/redo. **Cons:** Memory usage; compress history if needed.

---

## 11) Prototype Pattern

**Definition:** Create new objects by cloning existing ones (prototypal inheritance).

**When to use:**

* Many objects share shape/behavior; you want cheap cloning.

**Real‑world problem:** Duplicate a template data row with shared behaviors.

**Code:**

```js
const rowProto = {
  activate() { this.active = true; },
  deactivate() { this.active = false; }
};

function createRow(data) {
  return Object.assign(Object.create(rowProto), { ...data, active: false });
}

const r1 = createRow({ id: 1, name: "Alice" });
const r2 = Object.create(Object.getPrototypeOf(r1));
Object.assign(r2, { id: 2, name: "Bob", active: false });
```

**Pros:** Lightweight reuse. **Cons:** `this`/prototype chains can confuse—document factory functions.

---

## 12) Decorator Pattern

**Definition:** Add responsibilities to objects dynamically by wrapping them.

**When to use:**

* Add logging, caching, retry, rate limiting to existing functions/clients without modifying them.

**Real‑world problem:** Add caching to a fetcher.

**Code:**

```js
function withCache(fn, ttlMs = 5_000) {
  const cache = new Map();
  return async function(key) {
    const hit = cache.get(key);
    const now = Date.now();
    if (hit && now - hit.ts < ttlMs) return hit.value;
    const value = await fn(key);
    cache.set(key, { value, ts: now });
    return value;
  };
}

const fetchUser = async (id) => (await fetch(`/api/users/${id}`)).json();
const fetchUserCached = withCache(fetchUser, 10_000);
```

**Pros:** Composable behavior. **Cons:** Debugging stacks harder—name wrappers.

---

## 13) Adapter Pattern

**Definition:** Convert one interface to another clients expect.

**When to use:**

* Swap a library/service without rewriting callers.

**Real‑world problem:** Normalize two different analytics SDKs to a common API.

**Code:**

```js
function makeAnalyticsAdapter(sdk) {
  return {
    track(event, props) {
      if (sdk.logEvent) return sdk.logEvent(event, props); // Firebase style
      if (sdk.trackEvent) return sdk.trackEvent({ name: event, properties: props }); // Other SDK
      throw new Error("Unsupported SDK");
    }
  };
}

const analytics = makeAnalyticsAdapter(window.thirdPartySdk);
analytics.track("signup", { plan: "pro" });
```

**Pros:** Isolate change. **Cons:** Leaks if adapter incomplete—define contract.

---

## 14) Facade Pattern

**Definition:** Provide a simplified interface to a complex subsystem.

**When to use:**

* Hide messy multi‑step workflows behind a clean API.

**Real‑world problem:** Upload file + get URL + register metadata.

**Code:**

```js
function uploadAsset(file) {
  return fetch("/api/uploadUrl")
    .then((r) => r.json())
    .then(({ url }) => fetch(url, { method: "PUT", body: file }))
    .then(() => fetch("/api/assets", { method: "POST", body: JSON.stringify({ name: file.name }) }))
    .then((r) => r.json());
}

// Caller sees just one method
```

**Pros:** Cleaner call sites. **Cons:** Can hide errors—surface meaningful ones.

---

## 15) Iterator Pattern

**Definition:** Provide a way to access elements of an aggregate sequentially without exposing its internals.

**When to use:**

* Custom data sources, paginated APIs.

**Real‑world problem:** Iterate a paged HTTP API with `for await...of`.

**Code:**

```js
async function* fetchPages(url) {
  let next = url;
  while (next) {
    const res = await fetch(next).then(r => r.json());
    yield res.items;
    next = res.nextPageUrl; // or null
  }
}

(async () => {
  for await (const items of fetchPages("/api/list")) {
    // process each page
  }
})();
```

**Pros:** Clean consumption. **Cons:** Async iterators require modern runtime.

---

## 16) State vs Strategy (quick distinction)

* **Strategy**: choose algorithm based on input/context; switching is explicit by caller.
* **State**: object’s internal state controls behavior; switching is internal.

---

## 17) Proxy Pattern

**Definition:** A stand‑in that controls access to another object.

**When to use:**

* Lazy loading, access control, input validation, property watching.

**Real‑world problem:** Validate config access in dev.

**Code (`Proxy`):**

```js
function createStrictConfig(config) {
  return new Proxy(config, {
    get(target, prop) {
      if (!(prop in target)) throw new Error(`Unknown config key: ${String(prop)}`);
      return target[prop];
    }
  });
}

const Config = createStrictConfig({ API_URL: "/api" });
// Config.NON_EXISTENT -> throws
```

**Pros:** Powerful interception. **Cons:** Performance if overused; avoid in hot loops.

---

## 18) Chain of Responsibility Pattern

**Definition:** Pass a request along a chain of handlers; each can handle or pass it on.

**When to use:**

* Validation pipelines, middleware stacks.

**Real‑world problem:** HTTP request middleware.

**Code:**

```js
function chain(...handlers) {
  return (ctx) => handlers.reduce((c, h) => h(c), ctx);
}

const withAuth = (ctx) => { if (!ctx.user) throw new Error("unauthorized"); return ctx; };
const withRole = (role) => (ctx) => { if (ctx.user.role !== role) throw new Error("forbidden"); return ctx; };
const endpoint = (ctx) => ({ ok: true, userId: ctx.user.id });

const handler = chain(withAuth, withRole("admin"), endpoint);
// handler({ user: { id: 1, role: "admin" } }) -> { ok: true, userId: 1 }
```

**Pros:** Composable; readable. **Cons:** Debugging where it failed—log along the chain.

---

## 19) Flyweight Pattern

**Definition:** Share intrinsic state between many similar objects to save memory.

**When to use:**

* Thousands of similar objects (e.g., map markers, document characters) where most data is shared.

**Real‑world problem:** Virtualize emoji metadata shared across chat messages.

**Code:**

```js
const EmojiMeta = (function () {
  const cache = new Map(); // name -> meta
  return {
    get(name) {
      if (!cache.has(name)) cache.set(name, { url: `/emoji/${name}.png`, size: 24 });
      return cache.get(name);
    }
  };
})();

function createMessage(text, emojis) {
  return { text, emojis: emojis.map((n) => EmojiMeta.get(n)) };
}
```

**Pros:** Memory win. **Cons:** Complexity; premature optimization risk.

---

## 20) Template Method (Functional Flavor)

**Definition:** Define the skeleton of an algorithm, deferring steps to hooks.

**When to use:**

* Similar workflows with pluggable steps.

**Real‑world problem:** Data import pipeline with pre/transform/post hooks.

**Code:**

```js
function runImport({ before = async () => {}, transform, after = async () => {} }) {
  return async function(input) {
    await before(input);
    const out = await transform(input);
    await after(out);
    return out;
  };
}

const importCsv = runImport({
  before: async () => console.log("start"),
  transform: async (csv) => csv.trim().split("\n").map((r) => r.split(",")),
  after: async (rows) => console.log("rows:", rows.length)
});
```

---

## 21) Practical selection checklist

1. Is the problem just **encapsulation**? → Module/Revealing Module.
2. Is it about **one instance**? → Singleton (but prefer DI if testing heavy).
3. Is **object creation logic complex**? → Factory or Builder.
4. Need to **choose algorithm** at runtime? → Strategy. If the object’s behavior shifts by state → State.
5. Need **pub/sub**? → Observer. Need a **traffic controller**? → Mediator.
6. Want to **extend behavior** transparently? → Decorator or Proxy.
7. Facing **incompatible APIs**? → Adapter. Complex API too big? → Facade.
8. Need **undo/redo**? → Command. Need a **pipeline of validators**? → Chain of Responsibility.
9. Iterating **custom sequences** or **async pages**? → Iterator.
10. Scaling to **thousands of similar objects**? → Flyweight.

---

## 22) Anti‑patterns & cautions

* **Over‑engineering:** Prefer simple functions/modules first.
* **Singleton abuse:** Hard to test; leak hidden state across tests.
* **Observer spaghetti:** Trace with structured event names and logging.
* **Too many layers:** Adapter + Facade + Decorator can hide real errors; expose meaningful exceptions.

---

## 23) Testing tips (plain JS)

* Export factories that accept dependencies (fetch, logger) to unit test easily.
* For singletons, allow a reset in test builds.
* For async iterators, use `for await...of` with mocked `fetch`.
* For command history, assert state after sequences: do → undo → redo.

---

## 24) Appendix: Tiny utilities used above

```js
// Safe global for browser or Node
const G = typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : global);

// No‑op
const noop = () => {};
```

---

### License

This guide is MIT‑licensed. Copy, tweak, and paste freely in your projects.
