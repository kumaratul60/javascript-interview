# JavaScript Design Patterns — A Practical, Real‑World Guide

## [detail read refer this](https://github.com/kumaratul60/design-patterns)

> **Scope:** Pure JavaScript (browser + Node). Each pattern includes a clear definition, when to use, a realistic problem, how to implement, a compact code snippet, pros/cons, and quick tests.

---

## How to pick a pattern (quick map)

- **Organizing code / encapsulation** → Module, Revealing Module, Facade
- **One shared instance / shared cache** → Singleton
- **Create objects without `new` soup** → Factory, Builder
- **Swap algorithms at runtime** → Strategy, State
- **Broadcast events / decouple producers & consumers** → Observer (Pub/Sub), Mediator
- **Wrap/extend behavior without subclassing** → Decorator, Proxy
- **Make APIs compatible** → Adapter
- **Simplify a complex API** → Facade
- **Operate requests as objects** → Command, Chain of Responsibility
- **Control iteration** → Iterator
- **Optimize memory for many similar objects** → Flyweight
- **Share structure between objects** → Prototype

> Tip: Start with simplest pattern that solves the problem; avoid stacking patterns prematurely.

---

## 1) Module Pattern

**Definition:** Encapsulate private data/functions and expose a public API.

**When to use:**

- You need private variables in plain JS without classes.
- To group related functionality (e.g., cart, analytics, feature flags).

**Real‑world problem:** Prevent global leaks in an embeddable widget and expose a tiny API.

**Code (IIFE style):**

```js
const Cart = (function () {
  const items = new Map(); // private

  function add(productId, qty = 1) {
    items.set(productId, (items.get(productId) || 0) + qty);
  }
  function remove(productId) {
    items.delete(productId);
  }
  function totalQty() {
    let sum = 0;
    for (const q of items.values()) sum += q;
    return sum;
  }

  return { add, remove, totalQty }; // public API
})();

Cart.add('SKU123', 2);
console.log(Cart.totalQty()); // 2
```

**Pros:** Simple privacy, clear API. **Cons:** Harder to unit test private parts; not easily extensible.

**Quick tests:** No globals leaked, API surface minimal, private state truly inaccessible.

---

## 2) Revealing Module Pattern

**Definition:** Define all functions/vars privately, then return an object mapping private names to public ones.

**When to use:**

- Keep a consistent style: all functions at top, exports at bottom.
- Make it obvious what’s public.

**Real‑world problem:** Token storage wrapper that exposes only safe methods.

**Code:**

```js
const TokenStore = (function () {
  const KEY = 'app:token'; // private
  function set(token) {
    localStorage.setItem(KEY, token);
  }
  function get() {
    return localStorage.getItem(KEY);
  }
  function clear() {
    localStorage.removeItem(KEY);
  }

  // reveal what’s public
  return { setToken: set, getToken: get, clear };
})();

TokenStore.setToken('abc123');
```

**Pros:** Export list is the single source of truth. **Cons:** Same as Module; circular references harder.

---

## 3) Singleton Pattern

**Definition:** Ensure a class/object has only one instance and provide a global access point.

**When to use:**

- App‑wide config, logger, cache, DB connection, feature flag provider.
- You truly need single ownership of a resource.

**Real‑world problem:** Ensure only one analytics queue exists on a page with multiple bundles.

**Code (idempotent global attach):**

```js
class Analytics {
  constructor() {
    this.queue = [];
  }
  track(event, payload) {
    this.queue.push({ event, payload, ts: Date.now() });
  }
}

// Safe singleton across duplicate bundles
const AnalyticsSingleton = (function () {
  const GLOBAL_KEY = '__app_analytics__';
  if (!globalThis[GLOBAL_KEY]) {
    globalThis[GLOBAL_KEY] = new Analytics();
  }
  return globalThis[GLOBAL_KEY];
})();

AnalyticsSingleton.track('page_view', { path: location.pathname });
```

**Pros:** Single source of truth. **Cons:** Hidden dependencies; complicates tests—use DI to inject where possible.

---

## 4) Factory Pattern

**Definition:** Provide a function to create objects without exposing complex constructors.

**When to use:**

- You create many variants of a type based on input.
- Instantiation logic changes often (e.g., from config/env).

**Real‑world problem:** Create API clients switching base URL/auth by environment.

**Code:**

```js
function createHttpClient({ env = 'prod', token } = {}) {
  const base = env === 'dev' ? 'https://api.dev.local' : 'https://api.example.com';
  return {
    get(path) {
      return fetch(base + path, { headers: { Authorization: `Bearer ${token}` } });
    },
    post(path, body) {
      return fetch(base + path, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
        body: JSON.stringify(body),
      });
    },
  };
}

const client = createHttpClient({ env: 'dev', token: 't123' });
```

**Pros:** Centralize creation. **Cons:** Easy to hide complexity—document it.

---

## 5) Builder Pattern

**Definition:** Construct complex objects step by step via a fluent API.

**When to use:**

- Many optional fields / defaulting / validation.
- You need readable, staged construction.

**Real‑world problem:** Building a report export request.

**Code:**

```js
function ReportBuilder() {
  const req = { format: 'csv', filters: {}, columns: [] };
  return {
    format(fmt) {
      req.format = fmt;
      return this;
    },
    filter(key, val) {
      req.filters[key] = val;
      return this;
    },
    column(name) {
      req.columns.push(name);
      return this;
    },
    build() {
      if (req.columns.length === 0) throw new Error('At least one column');
      return { ...req };
    },
  };
}

const request = ReportBuilder().format('xlsx').filter('from', '2025-01-01').column('userId').column('revenue').build();
```

**Pros:** Fluent, validated. **Cons:** Extra abstraction; keep it lean.

---

## 6) Strategy Pattern

**Definition:** Define a family of algorithms, encapsulate each, and make them interchangeable.

**When to use:**

- You switch algorithms based on context (e.g., sorting, pricing rules, discount logic).

**Real‑world problem:** Different discount strategies by user tier.

**Code:**

```js
const strategies = {
  none: (amount) => amount,
  silver: (amount) => amount * 0.95,
  gold: (amount) => amount * 0.9,
};

function applyDiscount(amount, tier = 'none') {
  const fn = strategies[tier] || strategies.none;
  return fn(amount);
}

applyDiscount(100, 'gold'); // 90
```

**Pros:** Open/closed friendly. **Cons:** Too many small functions—document clearly.

---

## 7) State Pattern

**Definition:** Let an object change its behavior when its internal state changes.

**When to use:**

- UI components with modes (idle/loading/error), order lifecycle (draft/paid/shipped), auth guards.

**Real‑world problem:** Button that behaves differently by state.

**Code:**

```js
function createAsyncButton() {
  let state = 'idle'; // idle | loading | success | error
  const actions = {
    idle: () => {
      state = 'loading';
    },
    loading: () => {},
    success: () => {
      state = 'idle';
    },
    error: () => {
      state = 'idle';
    },
  };
  return {
    click() {
      actions[state]();
    },
    setState(s) {
      state = s;
    },
    getState() {
      return state;
    },
  };
}
```

**Pros:** Removes giant `if/else` blocks. **Cons:** More objects; keep states finite and explicit.

---

## 8) Observer (Publish/Subscribe) Pattern

**Definition:** Objects (subscribers) register interest in events from a subject (publisher).

**When to use:**

- Decouple data producers from UI, analytics, or logging.

**Real‑world problem:** Central event bus for cross‑feature communication.

**Code:**

```js
function createPubSub() {
  const topics = new Map(); // topic -> Set(listeners)
  return {
    subscribe(topic, listener) {
      if (!topics.has(topic)) topics.set(topic, new Set());
      topics.get(topic).add(listener);
      return () => topics.get(topic)?.delete(listener); // unsubscribe
    },
    publish(topic, data) {
      topics.get(topic)?.forEach((l) => l(data));
    },
  };
}

const bus = createPubSub();
const off = bus.subscribe('user:login', (u) => console.log('welcome', u.name));
bus.publish('user:login', { name: 'Atul' });
off();
```

**Pros:** Loosely coupled. **Cons:** Hard to trace flow—name topics clearly.

---

## 9) Mediator Pattern

**Definition:** Encapsulate how a set of objects interact; promotes loose coupling by preventing direct references.

**When to use:**

- Complex UIs where components must coordinate (wizard steps, chat presence + typing + messages).

**Real‑world problem:** Form wizard mediator controlling step transitions.

**Code:**

```js
function createWizardMediator(steps) {
  let current = 0;
  return {
    next() {
      if (steps[current].validate()) current++;
      steps[current]?.render();
    },
    prev() {
      if (current > 0) current--;
      steps[current].render();
    },
    currentIndex() {
      return current;
    },
  };
}
```

**Pros:** Centralizes coordination. **Cons:** Mediator can bloat—keep logic cohesive.

---

## 10) Command Pattern

**Definition:** Encapsulate a request as an object to parameterize, queue, log, and support undo/redo.

**When to use:**

- Editors (text/canvas), macro systems, retry queues.

**Real‑world problem:** Text editor operations with undo/redo.

**Code:**

```js
function createEditor() {
  let text = '';
  const history = [];
  const undone = [];

  const exec = (command) => {
    history.push(command);
    command.do();
    undone.length = 0;
  };
  const undo = () => {
    const c = history.pop();
    if (c) {
      c.undo();
      undone.push(c);
    }
  };
  const redo = () => {
    const c = undone.pop();
    if (c) {
      c.do();
      history.push(c);
    }
  };

  return {
    insert(pos, str) {
      exec({
        do: () => (text = text.slice(0, pos) + str + text.slice(pos)),
        undo: () => (text = text.slice(0, pos) + text.slice(pos + str.length)),
      });
    },
    remove(pos, len) {
      const old = text.slice(pos, pos + len);
      exec({
        do: () => (text = text.slice(0, pos) + text.slice(pos + len)),
        undo: () => (text = text.slice(0, pos) + old + text.slice(pos)),
      });
    },
    getText: () => text,
    undo,
    redo,
  };
}
```

**Pros:** Powerful undo/redo. **Cons:** Memory usage; compress history if needed.

---

## 11) Prototype Pattern

**Definition:** Create new objects by cloning existing ones (prototypal inheritance).

**When to use:**

- Many objects share shape/behavior; you want cheap cloning.

**Real‑world problem:** Duplicate a template data row with shared behaviors.

**Code:**

```js
const rowProto = {
  activate() {
    this.active = true;
  },
  deactivate() {
    this.active = false;
  },
};

function createRow(data) {
  return Object.assign(Object.create(rowProto), { ...data, active: false });
}

const r1 = createRow({ id: 1, name: 'Alice' });
const r2 = Object.create(Object.getPrototypeOf(r1));
Object.assign(r2, { id: 2, name: 'Bob', active: false });
```

**Pros:** Lightweight reuse. **Cons:** `this`/prototype chains can confuse—document factory functions.

---

## 12) Decorator Pattern

**Definition:** Add responsibilities to objects dynamically by wrapping them.

**When to use:**

- Add logging, caching, retry, rate limiting to existing functions/clients without modifying them.

**Real‑world problem:** Add caching to a fetcher.

**Code:**

```js
function withCache(fn, ttlMs = 5_000) {
  const cache = new Map();
  return async function (key) {
    const hit = cache.get(key);
    const now = Date.now();
    if (hit && now - hit.ts < ttlMs) return hit.value;
    const value = await fn(key);
    cache.set(key, { value, ts: now });
    return value;
  };
}

const fetchUser = async (id) => (await fetch(`/api/users/${id}`)).json();
const fetchUserCached = withCache(fetchUser, 10_000);
```

**Pros:** Composable behavior. **Cons:** Debugging stacks harder—name wrappers.

---

## 13) Adapter Pattern

**Definition:** Convert one interface to another clients expect.

**When to use:**

- Swap a library/service without rewriting callers.

**Real‑world problem:** Normalize two different analytics SDKs to a common API.

**Code:**

```js
function makeAnalyticsAdapter(sdk) {
  return {
    track(event, props) {
      if (sdk.logEvent) return sdk.logEvent(event, props); // Firebase style
      if (sdk.trackEvent) return sdk.trackEvent({ name: event, properties: props }); // Other SDK
      throw new Error('Unsupported SDK');
    },
  };
}

const analytics = makeAnalyticsAdapter(window.thirdPartySdk);
analytics.track('signup', { plan: 'pro' });
```

**Pros:** Isolate change. **Cons:** Leaks if adapter incomplete—define contract.

---

## 14) Facade Pattern

**Definition:** Provide a simplified interface to a complex subsystem.

**When to use:**

- Hide messy multi‑step workflows behind a clean API.

**Real‑world problem:** Upload file + get URL + register metadata.

**Code:**

```js
function uploadAsset(file) {
  return fetch('/api/uploadUrl')
    .then((r) => r.json())
    .then(({ url }) => fetch(url, { method: 'PUT', body: file }))
    .then(() => fetch('/api/assets', { method: 'POST', body: JSON.stringify({ name: file.name }) }))
    .then((r) => r.json());
}

// Caller sees just one method
```

**Pros:** Cleaner call sites. **Cons:** Can hide errors—surface meaningful ones.

---

## 15) Iterator Pattern

**Definition:** Provide a way to access elements of an aggregate sequentially without exposing its internals.

**When to use:**

- Custom data sources, paginated APIs.

**Real‑world problem:** Iterate a paged HTTP API with `for await...of`.

**Code:**

```js
async function* fetchPages(url) {
  let next = url;
  while (next) {
    const res = await fetch(next).then((r) => r.json());
    yield res.items;
    next = res.nextPageUrl; // or null
  }
}

(async () => {
  for await (const items of fetchPages('/api/list')) {
    // process each page
  }
})();
```

**Pros:** Clean consumption. **Cons:** Async iterators require modern runtime.

---

## 16) State vs Strategy (quick distinction)

- **Strategy**: choose algorithm based on input/context; switching is explicit by caller.
- **State**: object’s internal state controls behavior; switching is internal.

---

## 17) Proxy Pattern

**Definition:** A stand‑in that controls access to another object.

**When to use:**

- Lazy loading, access control, input validation, property watching.

**Real‑world problem:** Validate config access in dev.

**Code (`Proxy`):**

```js
function createStrictConfig(config) {
  return new Proxy(config, {
    get(target, prop) {
      if (!(prop in target)) throw new Error(`Unknown config key: ${String(prop)}`);
      return target[prop];
    },
  });
}

const Config = createStrictConfig({ API_URL: '/api' });
// Config.NON_EXISTENT -> throws
```

**Pros:** Powerful interception. **Cons:** Performance if overused; avoid in hot loops.

---

## 18) Chain of Responsibility Pattern

**Definition:** Pass a request along a chain of handlers; each can handle or pass it on.

**When to use:**

- Validation pipelines, middleware stacks.

**Real‑world problem:** HTTP request middleware.

**Code:**

```js
function chain(...handlers) {
  return (ctx) => handlers.reduce((c, h) => h(c), ctx);
}

const withAuth = (ctx) => {
  if (!ctx.user) throw new Error('unauthorized');
  return ctx;
};
const withRole = (role) => (ctx) => {
  if (ctx.user.role !== role) throw new Error('forbidden');
  return ctx;
};
const endpoint = (ctx) => ({ ok: true, userId: ctx.user.id });

const handler = chain(withAuth, withRole('admin'), endpoint);
// handler({ user: { id: 1, role: "admin" } }) -> { ok: true, userId: 1 }
```

**Pros:** Composable; readable. **Cons:** Debugging where it failed—log along the chain.

---

## 19) Flyweight Pattern

**Definition:** Share intrinsic state between many similar objects to save memory.

**When to use:**

- Thousands of similar objects (e.g., map markers, document characters) where most data is shared.

**Real‑world problem:** Virtualize emoji metadata shared across chat messages.

**Code:**

```js
const EmojiMeta = (function () {
  const cache = new Map(); // name -> meta
  return {
    get(name) {
      if (!cache.has(name)) cache.set(name, { url: `/emoji/${name}.png`, size: 24 });
      return cache.get(name);
    },
  };
})();

function createMessage(text, emojis) {
  return { text, emojis: emojis.map((n) => EmojiMeta.get(n)) };
}
```

**Pros:** Memory win. **Cons:** Complexity; premature optimization risk.

---

## 20) Template Method (Functional Flavor)

**Definition:** Define the skeleton of an algorithm, deferring steps to hooks.

**When to use:**

- Similar workflows with pluggable steps.

**Real‑world problem:** Data import pipeline with pre/transform/post hooks.

**Code:**

```js
function runImport({ before = async () => {}, transform, after = async () => {} }) {
  return async function (input) {
    await before(input);
    const out = await transform(input);
    await after(out);
    return out;
  };
}

const importCsv = runImport({
  before: async () => console.log('start'),
  transform: async (csv) =>
    csv
      .trim()
      .split('\n')
      .map((r) => r.split(',')),
  after: async (rows) => console.log('rows:', rows.length),
});
```

---

## 21) Practical selection checklist

1. Is the problem just **encapsulation**? → Module/Revealing Module.
2. Is it about **one instance**? → Singleton (but prefer DI if testing heavy).
3. Is **object creation logic complex**? → Factory or Builder.
4. Need to **choose algorithm** at runtime? → Strategy. If the object’s behavior shifts by state → State.
5. Need **pub/sub**? → Observer. Need a **traffic controller**? → Mediator.
6. Want to **extend behavior** transparently? → Decorator or Proxy.
7. Facing **incompatible APIs**? → Adapter. Complex API too big? → Facade.
8. Need **undo/redo**? → Command. Need a **pipeline of validators**? → Chain of Responsibility.
9. Iterating **custom sequences** or **async pages**? → Iterator.
10. Scaling to **thousands of similar objects**? → Flyweight.

---

## 22) Anti‑patterns & cautions

- **Over‑engineering:** Prefer simple functions/modules first.
- **Singleton abuse:** Hard to test; leak hidden state across tests.
- **Observer spaghetti:** Trace with structured event names and logging.
- **Too many layers:** Adapter + Facade + Decorator can hide real errors; expose meaningful exceptions.

---

## 23) Testing tips (plain JS)

- Export factories that accept dependencies (fetch, logger) to unit test easily.
- For singletons, allow a reset in test builds.
- For async iterators, use `for await...of` with mocked `fetch`.
- For command history, assert state after sequences: do → undo → redo.

---

## 24) Appendix: Tiny utilities used above

```js
// Safe global for browser or Node
const G = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : global;

// No‑op
const noop = () => {};
```

---

### License

This guide is MIT‑licensed. Copy, tweak, and paste freely in your projects.
